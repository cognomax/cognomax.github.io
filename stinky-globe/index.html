<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>stinky globe</title>
  <style>
    :root{
      --tan: #f1e6b6;      /* hub background */
      --ocean: #66d9ff;    /* hover button blue */
      --ink: #0a0a0a;
    }
    html, body { height: 100%; margin: 0; }
    body{
      background: var(--tan);
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    #wrap{
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
    }
    canvas { display: block; }
    .hint{
      position: fixed;
      left: 18px;
      bottom: 14px;
      color: var(--ink);
      opacity: 0.7;
      font-size: 13px;
      user-select: none;
    }
    .back{
      position: fixed;
      right: 18px;
      bottom: 14px;
      color: var(--ink);
      opacity: 0.75;
      text-decoration: none;
      font-size: 13px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(10,10,10,0.25);
      background: rgba(241,230,182,0.65);
      backdrop-filter: blur(6px);
    }
    .back:hover{ opacity: 1; }
  </style>
</head>
<body>
  <div id="wrap"></div>
  <div class="hint">drag to rotate • scroll to zoom</div>
  <a class="back" href="../">← back</a>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>

  <script>
    const TAN = '#f1e6b6';
    const OCEAN = '#66d9ff';
    const INK = '#0a0a0a';

    // Pastel color generator
    function pastelColor(id) {
      const hash = (id * 2654435761) >>> 0;
      const hue = hash % 360;
      return `hsl(${hue}, 45%, 82%)`;
    }

    // Create texture with pastel countries
    async function createTexture() {
      const W = 4096, H = 2048;
      const canvas = document.createElement('canvas');
      canvas.width = W;
      canvas.height = H;
      const ctx = canvas.getContext('2d');

      // Ocean background
      ctx.fillStyle = OCEAN;
      ctx.fillRect(0, 0, W, H);

      // Projection
      const projection = d3.geoEquirectangular()
        .translate([W / 2, H / 2])
        .scale(W / (2 * Math.PI));
      const path = d3.geoPath(projection, ctx);

      // Load countries
      const topo = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json').then(r => r.json());
      const countries = topojson.feature(topo, topo.objects.countries).features;

      // Draw countries with pastel colors
      countries.forEach(f => {
        ctx.beginPath();
        path(f);
        ctx.fillStyle = pastelColor(+f.id || 1);
        ctx.fill();
      });

      // Draw borders
      ctx.strokeStyle = INK;
      ctx.lineWidth = 1.5;
      countries.forEach(f => {
        ctx.beginPath();
        path(f);
        ctx.stroke();
      });

      return canvas;
    }

    // Setup Three.js
    const container = document.getElementById('wrap');
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setClearColor(TAN);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 3.2;

    // Create globe group
    const globeGroup = new THREE.Group();
    scene.add(globeGroup);

    // Load texture and create globe
    createTexture().then(canvas => {
      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;

      const geometry = new THREE.SphereGeometry(1, 128, 128);
      const material = new THREE.MeshBasicMaterial({ map: texture });
      const globe = new THREE.Mesh(geometry, material);
      globeGroup.add(globe);

      // Thin black outline
      const outlineGeo = new THREE.SphereGeometry(1, 128, 128);
      const outlineMat = new THREE.MeshBasicMaterial({
        color: INK,
        side: THREE.BackSide
      });
      const outline = new THREE.Mesh(outlineGeo, outlineMat);
      outline.scale.set(1.005, 1.005, 1.005);
      globeGroup.add(outline);

      // Simple orbit controls
      let isDragging = false;
      let lastX = 0, lastY = 0;
      let rotateX = 0, rotateY = 0;

      renderer.domElement.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      });

      renderer.domElement.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const deltaX = e.clientX - lastX;
          const deltaY = e.clientY - lastY;
          rotateY += deltaX * 0.01;
          rotateX += deltaY * 0.01;
          lastX = e.clientX;
          lastY = e.clientY;
        }
      });

      renderer.domElement.addEventListener('mouseup', () => {
        isDragging = false;
      });

      renderer.domElement.addEventListener('wheel', (e) => {
        e.preventDefault();
        camera.position.z += e.deltaY * 0.01;
        camera.position.z = Math.max(2.2, Math.min(6.0, camera.position.z));
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        
        if (!isDragging) {
          globeGroup.rotation.y -= 0.0006; // slow horizontal spin (right to left)
        } else {
          globeGroup.rotation.y = rotateY;
          globeGroup.rotation.x = rotateX;
        }

        renderer.render(scene, camera);
      }
      animate();
    }).catch(err => {
      console.error('Error loading globe:', err);
    });

    // Resize handler
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
